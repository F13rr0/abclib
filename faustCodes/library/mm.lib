//################################### hoa.lib ############################################
// Faust library for mixed music. Its official prefix is `mm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/mm.lib>
//########################################################################################

/************************************************************************
 ************************************************************************
FAUST library file
Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

ba = library("basics.lib");
si = library("signals.lib");

declare name "Mixed Music library";
declare author "Alain Bonardi";
declare copyright "2022- Bonardi, CICM / MUSIDANSE, U. Paris 8";

//==================================General functions=====================================
//========================================================================================

//--------------------------------------------------------------------------------------//
//CLIP FUNCTIONS
//--------------------------------------------------------------------------------------//
//-------`(mm.)clip`----------
// Clips the signal between a and b (a is the minimum value, b the maximum value, a <= b)

// `clip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : clip(x, a, b) : _
// ```
//
// Where:
//
// * `x`: the incoming signal
// * `a': the minimum value
// * `b`: the maximum value
//-----------------------------

clip(x, a, b) = min(max(x, a), b);

//-------`(mm.)sigClip`----------
// Clips the signal between -1 and 1 (usual clip for signals)

// `sigClip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : sigClip : _
// ```
//
//-----------------------------

sigClip = (_, -1, 1) : clip;

//-------`(mm.)ampClip`----------
// Clips the signal between 0 and 1, as an amplitude

// `ampClip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : ampClip : _
// ```
//
//-----------------------------

ampClip = (_, 0, 1) : clip;

//--------------------------------------------------------------------------------------//
// SCALE AND ZMAP FUNCTIONS
//--------------------------------------------------------------------------------------//

//-------`(mm.)scale`----------
// Converts a signal x from scale [x1; x2] to scale [y1; y2]
// x1 and x2 can be provided in any order
// y1 and y2 can be provided in any order
// if x1==x2, x is returned

// `scale` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : scale(x, x1, x2, y1, y2) : _
// ```
//
//-----------------------------

scale(x, x1, x2, y1, y2) = ba.if(x1 != x2, (x - a1) * (b2 - b1) / (a2 - a1) + b1, x)
	with {
			a1 = min(x1, x2);
			a2 = max(x1, x2);
			b1 = min(y1, y2);
			b2 = max(y1, y2);
	};

//-------`(mm.)zmap`----------
// zmap has the same behaviour as scale but clips values to the [x1; x2] and [y1; y2] ranges
// x1 and x2 can be provided in any order
// y1 and y2 can be provided in any order
// if x1==x2, x is returned

// `zmap` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : zmap(x, x1, x2, y1, y2) : _
// ```
//
//-----------------------------

zmap(x, x1, x2, y1, y2) = scale(clip(x, x1, x2), x1, x2, y1, y2);

//--------------------------------------------------------------------------------------//
// BUS FUNCTIONS
//--------------------------------------------------------------------------------------//

//-------`(mm.)interlace2`----------
// interlace2 is a bus function that interleaves 2 buses of signals
// starting with 2n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn
// the result is the vector sigA1, sigB1, sigA2, sigB2, ..., sigAn, sigBn

// `interlace2` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : interlace2 : _,_,...
// ```
//
//-----------------------------

interlace2(n) = si.bus(2*n) <: par(i, n, (ba.selector(i, 2*n), ba.selector(i+n, 2*n)));

//-------`(mm.)interlace3`----------
// interlace2 is a bus function that interleaves 3 buses of signals
// starting with 3n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn, sigC1, sigC2, ..., sigCn
// the result is the vector sigA1, sigC1, sigB1, sigA2, sigC2, sigB2, ..., sigAn, sigCn, sigBn

// `interlace3` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : interlace3 : _,_,...
// ```
//
//-----------------------------

interlace3(n) = si.bus(3*n) <: par(i, n, (ba.selector(i, 3*n), ba.selector(i+2*n, 3*n), ba.selector(i+n, 3*n)));

//-------`(mm.)invbus`----------
// invbus is a bus function that inverts the order of the n signals of a bus
// (1st input => N, 2nd => N-1, 3rd => N-2, etc)

// `invbus` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : invbus : _,_,...
// ```
//
//-----------------------------

invbus(n) = par(j, n, _ <: par(i, n, *(i==n-j-1))) :> si.bus(n);

//--------------------------------------------------------------------------------------//
//ENVELOPES
//--------------------------------------------------------------------------------------//

//-------`(mm.)pulsedEnv`----------
// pulsedEnv generates a pulsed envelope at a certain rate (frequency)
// and a certain ratio (for instance 3 indicates that signal is on during 1/3 of the period)

// `pulsedEnv` is a standard Faust function.
//
// #### Usage
//
// ```
// pulsedEnv(rate, ratio) : _
// ```
//
//-----------------------------

pulsedEnv(rate, ratio) = os.osccos(rate) <: * : *(ratio) : -(ratio-1) : ampClip;


//--------------------------------------------------------------------------------------//
//SOUND SYNTHESES
//--------------------------------------------------------------------------------------//

//-------`(mm.)puckettesPaf`----------
// puckettesPaf generates a phased-aligned formant signal
// using Miller Puckette's design exposed in the following article:
// reference: http://msp.ucsd.edu/techniques/v0.11/book-html/node96.html

// `puckettesPaf` is a standard Faust function.
//
// #### Usage
//
// ```
// puckettesPaf(fund, cfreq, bwidth, a, sgauss, acauchy, wfunc) : _
// ```
//
// Where:
//
// * `fund`: the fundamental frequency (Hz)
// * `cfreq': the central frequency (Hz)
// * `bwidth`: the band width (Hz)
// * 'a' : the output amplitude between 0 and 1
// * 'sgauss' : the standard deviation of the gauss function to be used
// * 'acauchy' : the a coefficient of Cauchy function
// * 'wfunc' : the chosen wave function in the modulator (0 stands for Gauss, 1 for Cauchy)
//-----------------------------

puckettesPaf(fund, cfreq, bwidth, a, sgauss, acauchy, wfunc) = (carrier, modulator) : * : *(a)  
		with {
				ratio = (cfreq / fund);
				ph = os.phasor(1, fund);
				th = ph <: (_, @(1)) : ((_ > 0.00001), (_ <= 0.00001)) : *;
				//looking for k so that cf belongs to [kf0; (k+1)f0]
				k = (ratio - ma.frac(ratio)) : ba.sAndH(th); //computation of k coefficient
				q = ratio - k;
				p = 1 - q;
				//
				carrier = ph <: (*(k * 2 * ma.PI), *((k +1) * 2 * ma.PI)) : (cos, cos) : +;
				//index of modulation = b
				//
				b = bwidth / fund;
				index = os.oscsin(fund / 2) : abs : *(b); 
				//
				//gaussian without dividing by sigma to avoid output amplitude variation
				gaussian(x) = pow(2.71828, -0.5*pow(x/sgauss, 2.));
				//cauchy
				cauchy(x) = acauchy / (x * x + acauchy * acauchy);
				clip0to10(x) = min(max(x, 0), 10);
				//modulator
				modulator = index <: (gaussian, cauchy) : (*(1 - wfunc), *(wfunc)) : + : clip0to10;			
};