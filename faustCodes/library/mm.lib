//################################### hoa.lib ############################################
// Faust library for mixed music. Its official prefix is `mm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/mm.lib>
//########################################################################################

/************************************************************************
 ************************************************************************
FAUST library file
Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

ba = library("basics.lib");
si = library("signals.lib");

declare name "Mixed Music library";
declare author "Alain Bonardi";
declare copyright "2022- Bonardi, CICM / MUSIDANSE, U. Paris 8";

//==================================General functions=====================================
//========================================================================================

//--------------------------------------------------------------------------------------//
//CLIP FUNCTIONS
//--------------------------------------------------------------------------------------//
//-------`(mm.)clip`----------
// Clips the signal between a and b (a is the minimum value, b the maximum value, a <= b)

// `clip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : clip(x, a, b) : _
// ```
//
// Where:
//
// * `x`: the incoming signal
// * `a': the minimum value
// * `b`: the maximum value
//-----------------------------

clip(x, a, b) = min(max(x, a), b);

//-------`(mm.)sigClip`----------
// Clips the signal between -1 and 1 (usual clip for signals)

// `sigClip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : sigClip : _
// ```
//
//-----------------------------

sigClip = (_, -1, 1) : clip;

//-------`(mm.)ampClip`----------
// Clips the signal between 0 and 1, as an amplitude

// `ampClip` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : ampClip : _
// ```
//
//-----------------------------

ampClip = (_, 0, 1) : clip;

//--------------------------------------------------------------------------------------//
// SCALE AND ZMAP FUNCTIONS
//--------------------------------------------------------------------------------------//

//-------`(mm.)scale`----------
// Converts a signal x from scale [x1; x2] to scale [y1; y2]
// x1 and x2 can be provided in any order
// y1 and y2 can be provided in any order
// if x1==x2, x is returned

// `scale` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : scale(x, x1, x2, y1, y2) : _
// ```
//
//-----------------------------

scale(x, x1, x2, y1, y2) = ba.if(x1 != x2, (x - a1) * (b2 - b1) / (a2 - a1) + b1, x)
	with {
			a1 = min(x1, x2);
			a2 = max(x1, x2);
			b1 = min(y1, y2);
			b2 = max(y1, y2);
	};

//-------`(mm.)zmap`----------
// zmap has the same behaviour as scale but clips values to the [x1; x2] and [y1; y2] ranges
// x1 and x2 can be provided in any order
// y1 and y2 can be provided in any order
// if x1==x2, x is returned

// `zmap` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : zmap(x, x1, x2, y1, y2) : _
// ```
//
//-----------------------------

zmap(x, x1, x2, y1, y2) = scale(clip(x, x1, x2), x1, x2, y1, y2);

//--------------------------------------------------------------------------------------//
// BUS FUNCTIONS
//--------------------------------------------------------------------------------------//

//-------`(mm.)interlace2`----------
// interlace2 is a bus function that interleaves 2 buses of signals
// starting with 2n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn
// the result is the vector sigA1, sigB1, sigA2, sigB2, ..., sigAn, sigBn

// `interlace2` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : interlace2 : _,_,...
// ```
//
//-----------------------------

interlace2(n) = si.bus(2*n) <: par(i, n, (ba.selector(i, 2*n), ba.selector(i+n, 2*n)));

//-------`(mm.)interlace3`----------
// interlace3 is a bus function that interleaves 3 buses of signals
// starting with 3n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn, sigC1, sigC2, ..., sigCn
// the result is the vector sigA1, sigC1, sigB1, sigA2, sigC2, sigB2, ..., sigAn, sigCn, sigBn

// `interlace3` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : interlace3 : _,_,...
// ```
//
//-----------------------------

interlace3(n) = si.bus(3*n) <: par(i, n, (ba.selector(i, 3*n), ba.selector(i+2*n, 3*n), ba.selector(i+n, 3*n)));

//-------`(mm.)invbus`----------
// invbus is a bus function that inverts the order of the n signals of a bus
// (1st input => N, 2nd => N-1, 3rd => N-2, etc)

// `invbus` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : invbus : _,_,...
// ```
//
//-----------------------------

invBus(n) = par(j, n, _ <: par(i, n, *(i==n-j-1))) :> si.bus(n);


// number of channels, transition time in samples, left (0) or right (1)
busSelector(n, dt, lor) = thisBusSelector
			with {
					sel = lor : ba.line(dt); 
					thisBusSelector = (par(i, n, *(1-sel)), par(i, n, *(sel))) :> si.bus(n);
};


//PROCESSES

//--------------------------------------------------------------------------------------//
//CHOWNING PANNERS
//--------------------------------------------------------------------------------------//
//defined as a multiple panner with regular progression of pan angle from phi0 to -phi0
//--------------------------------------------------------------------------------------//
chowningPanner(as, ahp) = _ <: (*(chowningLeftLevel), *(chowningRighLevel))
			with {
			//as is the incident angle of the source//
			//ahp is the angle of the left loudspeaker, the right loudspeaker being at -ahp//
			//we chose clockwise convention
			//
			aseff = max(min(ahp, as), -ahp);//to force as to be between -ahp and ahp//
			chowningLeftLevel = sqrt((ahp - aseff)/(2*ahp));
			chowningRighLevel = sqrt((ahp + aseff)/(2*ahp));
 	};
//
//with several input sources
multiChowningPanner(n, ahp, amp) = par(i, n, (chowningPanner(ahp*(2*i/(n-1)-1), ahp))) :> (*(amp), *(amp));


//--------------------------------------------------------------------------------------//
//ENVELOPES
//--------------------------------------------------------------------------------------//

//-------`(mm.)pulsedEnv`----------
// pulsedEnv generates a pulsed envelope at a certain rate (frequency)
// and a certain ratio (for instance 3 indicates that signal is on during 1/3 of the period)

// `pulsedEnv` is a standard Faust function.
//
// #### Usage
//
// ```
// pulsedEnv(rate, ratio) : _
// ```
//
//-----------------------------

pulsedEnv(rate, ratio) = os.osccos(rate) <: * : *(ratio) : -(ratio-1) : ampClip;


//--------------------------------------------------------------------------------------//
//SOUND SYNTHESES
//--------------------------------------------------------------------------------------//


//--------------------------------------------------------------------------------------//
//DOUBLE OSCILLATOR
//--------------------------------------------------------------------------------------//
//2 added oscillators as harmonics of a fundamental frequency and shifted//
//f is the fundamental, n the multiplier, deltaf the shift frequency to get a beat//
//
doubleOscillator(f, n, deltaf) = (f*n) <: (_, +(deltaf)) : (os.osci, os.osci) : + : *(0.5);

//[TO BE TESTED]

//-------`(mm.)puckettesPaf`----------
// puckettesPaf generates a phased-aligned formant signal
// using Miller Puckette's design exposed in the following article:
// reference: http://msp.ucsd.edu/techniques/v0.11/book-html/node96.html

// `puckettesPaf` is a standard Faust function.
//
// #### Usage
//
// ```
// puckettesPaf(fund, cfreq, bwidth, a, sgauss, acauchy, wfunc) : _
// ```
//
// Where:
//
// * `fund`: the fundamental frequency (Hz)
// * `cfreq': the central frequency (Hz)
// * `bwidth`: the band width (Hz)
// * 'a' : the output amplitude between 0 and 1
// * 'sgauss' : the standard deviation of the gauss function to be used
// * 'acauchy' : the a coefficient of Cauchy function
// * 'wfunc' : the chosen wave function in the modulator (0 stands for Gauss, 1 for Cauchy)
//-----------------------------

puckettesPaf(fund, cfreq, bwidth, a, sgauss, acauchy, wfunc) = (carrier, modulator) : * : *(a)  
		with {
				ratio = (cfreq / fund);
				ph = os.phasor(1, fund);
				th = ph <: (_, @(1)) : ((_ > 0.00001), (_ <= 0.00001)) : *;
				//looking for k so that cf belongs to [kf0; (k+1)f0]
				k = (ratio - ma.frac(ratio)) : ba.sAndH(th); //computation of k coefficient
				q = ratio - k;
				p = 1 - q;
				//
				carrier = ph <: (*(k * 2 * ma.PI), *((k +1) * 2 * ma.PI)) : (cos, cos) : +;
				//index of modulation = b
				//
				b = bwidth / fund;
				index = os.oscsin(fund / 2) : abs : *(b); 
				//
				//gaussian without dividing by sigma to avoid output amplitude variation
				gaussian(x) = pow(2.71828, -0.5*pow(x/sgauss, 2.));
				//cauchy
				cauchy(x) = acauchy / (x * x + acauchy * acauchy);
				clip0to10(x) = min(max(x, 0), 10);
				//modulator
				modulator = index <: (gaussian, cauchy) : (*(1 - wfunc), *(wfunc)) : + : clip0to10;			
};

//[TO BE TESTED]

//-------`(mm.)puckettesPaf2`----------
// puckettesPaf2 generates a phased-aligned formant signal like puckettesPaf function
// but it adds a phase modulator that enables the synthesis of inharmonic sounds
// It uses Miller Puckette's design exposed in the following article:
// reference: http://msp.ucsd.edu/techniques/v0.11/book-html/node96.html

// `puckettesPaf2` is a standard Faust function.
//
// #### Usage
//
// ```
// puckettesPaf2(fund, cfreq, bwidth, a, inharmoAmp, inharmoFreq, sgauss, acauchy, wfunc) : _
// ```
//
// Where:
//
// * `fund`: the fundamental frequency (Hz)
// * `cfreq': the central frequency (Hz)
// * `bwidth`: the band width (Hz)
// * 'a' : the output amplitude between 0 and 1
// * 'inharmoAmp' : the amplitude of inharmonic sound generated
// * 'inharmoFreq' : the frequency of inharmonic sound generated
// * 'sgauss' : the standard deviation of the gauss function to be used
// * 'acauchy' : the a coefficient of Cauchy function
// * 'wfunc' : the chosen wave function in the modulator (0 stands for Gauss, 1 for Cauchy)
//-----------------------------
puckettesPaf2(fund, cfreq, bwidth, a, inharmoAmp, inharmoFreq, sgauss, acauchy, wfunc) = (carrier, modulator) : * : *(a)  
		with {
				ratio = (cfreq / fund);
				ph = os.phasor(1, fund);
				th = ph <: (_, @(1)) : ((_ > 0.00001), (_ <= 0.00001)) : *;
				//looking for k so that cf belongs to [kf0; (k+1)f0]
				k = (ratio - ma.frac(ratio)) : ba.sAndH(th); //computation of k coefficient
				q = ratio - k;
				p = 1 - q;
				//
				phaseModulator = os.osccos(inharmoFreq) : *(inharmoAmp);
				//
				carrier = ph : +(phaseModulator) <: (*(k * 2 * ma.PI), *((k +1) * 2 * ma.PI)) : (cos, cos) : +;
				//index of modulation = b
				//
				b = bwidth / fund;
				index = os.oscsin(fund / 2) : abs : *(b); 
				//
				//gaussian without dividing by sigma to avoid output amplitude variation
				gaussian(x) = pow(2.71828, -0.5*pow(x/sgauss, 2.));
				//cauchy
				cauchy(x) = acauchy / (x * x + acauchy * acauchy );
				clip0to10(x) = min(max(x, 0), 10);
				//modulator
				modulator = index <: (gaussian, cauchy) : (*(1 - wfunc), *(wfunc)) : + : clip0to10;			
};


//-------`(mm.)soundcoat`----------
// Synthesizes an harmonic sound using n bandpass filters centered on partials of a fundamental frequency applied to white noise signals
// the gain of each filter is randomized

// `soundcoat` is a standard Faust function.
//
// #### Usage
//
// ```
// soundcoat(n, fund, frand, g) : _
// ```
//
// Where:
//
// * `n`: the number of bandpass filters
// * `fund': the fundamental frequency (in Hz)
// * `frand`: the update frequency of filter gains (randomization)
// * 'g' : the output amplitude between 0 and 1
//-----------------------------

soundcoat(n, fund, frand, g) = no.multinoise(2) : ((_ <: si.bus(n)), (_ <: si.bus(n))) : interlace2(n) : par(i, n, elemFilter(fund, frand, i+1, n)) :> _ : *(0.08) : *(g)
			with {
				elemFilter(fund, frand, i, n) = (_, _) : (_, randVol) : (fi.resonbp(fund * i, filterQ, filterG), _) : *
				//An elementary bandpass filter with randomized gain
				//two inputs for abc_elemfilter: left is the signal to filter, right is a random noise (from a decorrelated vector of noise)
						with {	
								filterQ = 120;
								filterG = 1;
								ramp = os.phasor(1, frand) : +(i/n) : ma.decimal;		
								th = (ramp > 0.001) * (ramp@1 <= 0.001);
								randVol = +(1) : *(0.1) : ba.sAndH(th) : si.smooth(ba.tau2pole(1));
						};
};


//2 inputs:
// - left input is the possible signal to filter when the bell is used in substractive synthesis with filters//
// - right input is the trigger command to trigger the bell (for instance a button in Faust)
rissetsbell(d, fund, pf2, rq, rg, of, g) = (_, _) <: (bell1, bell2, bell3, bell4, bell5, bell6, bell7, bell8, bell9, bell10, bell11)
			with {
				//
				bellEnveloppe(dur, attack, rdur) = (0.005, bellDur, _) : en.ar : *(envamp) <:(_, _) : * <:(_, _) : *
						with {
							envamp = sqrt(sqrt(attack * 0.1));
							bellDur = rdur * dur;
				};
				//
				bellOscillator2(freq, rfreq, detune, pfreq2) = (os.osccos(fr1), os.osccos(fr2)) : (*(a1), *(a2)) : +
						with {
							fr1 = rfreq*freq+detune;
							fr2 = fr1 * pfreq2;	
							test = (pfreq2 == 1.);
							a1 = 0.5*(1+test);
							a2 = 0.5*(1-test);
				};
				//
				bellGenerator2(attack, rdur, rfreq, detune, dur, freq, pfreq2, resq, resg, osc2filter, gain) = crossoscfilter : *(gain)
						with {
							fc = rfreq*freq+detune;
							filter = fi.resonbp(fc, resq, resg);
							crossoscfilter = (osc2filter*filter+(1-osc2filter)*bellOscillator2(freq, rfreq, detune, pfreq2))*bellEnveloppe(dur, attack, rdur);
				};
				//
				bell1 = bellGenerator2(1, 1, 0.56, 0., d, fund, pf2, rq, rg, of, g);
				bell2 = bellGenerator2(0.67, 0.9, 0.56, 1., d, fund, pf2, rq, rg, of, g);
				bell3 = bellGenerator2(1, 0.65, 0.92, 0., d, fund, pf2, rq, rg, of, g);
				bell4 = bellGenerator2(1.8, 0.55, 0.92, 1.7, d, fund, pf2, rq, rg, of, g);
				bell5 = bellGenerator2(2.67, 0.325, 1.19, 0., d, fund, pf2, rq, rg, of, g);
				bell6 = bellGenerator2(1.67, 0.35, 1.7, 0., d, fund, pf2, rq, rg, of, g);
				bell7 = bellGenerator2(1.46, 0.25, 2., 0., d, fund, pf2, rq, rg, of, g);
				bell8 = bellGenerator2(1.33, 0.2, 2.74, 0., d, fund, pf2, rq, rg, of, g);
				bell9 = bellGenerator2(1.33, 0.15, 3., 0., d, fund, pf2, rq, rg, of, g);
				bell10 = bellGenerator2(1., 0.1, 3.76, 0., d, fund, pf2, rq, rg, of, g);
				bell11 = bellGenerator2(1.33, 0.075, 4.07, 0., d, fund, pf2, rq, rg, of, g);
};

audiotester(n, nmax, f, g) = thisaudiotester
			with {
				dur = 1000 / f; //duration in milliseconds between two envelopes//
				globalfreq = f / n; //global frequency of the whole cycle of loudspeakers
				//
				//we define an impulsion at the frequency freq
				impulse = ba.pulse(int(dur * ma.SR / 1000));
				//we define a counter from 0 to n-1
				counter = (_, (os.phasor(n, globalfreq) : int)) : ba.sAndH;
				//
				//we define a pink noise generator with an ar envelope
				generator = (((0.005, (dur * 0.5 / 1000), _) : en.ar), no.pink_noise) : * : *(g);
				//
				//we define a selector to choose one output #x
				selector(x) = _ <: par(i, nmax, *(x == i));
				//
				//the audiotester
				thisaudiotester = impulse <: (counter, generator) : selector;
};

peakamp(n) = maxVal(n) : ba.sAndH(getPeak) with {
	maxVal(n) = (_, abs) ~ (max : *(1 - resetMax)) : (_, !);
	resetMax = ba.pulse(n)@1;
	getPeak = ba.pulse(n);
};