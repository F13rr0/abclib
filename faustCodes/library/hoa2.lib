//-------`(ho.)encoder2`----------
// Ambisonic encoder in 2D
// a mono signal is encoded at at certain ambisonic order
// with two possible modes: either rotation with an angular speed, or static with a fixed angle.

// `encoder2` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : encoder2(n, sp, a, it) : _,_, ...
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 outputs to the encoder2 function)
// * `sp': the speed expressed as angular speed (2PI/sec)
// * `a`: the fixed angle when the rotation stops (sp = 0)
// * 'it' : interpolation time (in milliseconds) between the rotation and the fixed modes.
//-----------------------------
encoder2(n, sp, a, it) = thisEncoder
	with {
			basicEncoder(sig, angle) = ho.encoder(n, sig, angle);
			thisEncoder = (_, rotationOrStaticAngle) : basicEncoder
				with {
						rotationOrStaticAngle = (1-vn) * x + vn * a;
						vn = (sp == 0) : si.smooth(ba.tau2pole(it));
						//to manage the case where frequency is zero, smoothly switches from one mode to another//
						x = (os.phasor(1, sp), a, 1) : (+, _) : fmod;
				};
};

//-------`(ho.)decoderStereo2`----------
// Ambisonic stereo decoder in 2D
// with control of the direction of implementation of the 2 loudspeakers (either direct (clockwise) or not)
// and output amplitude

// `decoderStereo2` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : decoderStereo2(n,d,g) : _,_
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 inputs to the decoderStereo2 function)
// * `cw`: 1 for direct (clockwise) mode, -1 for the indirect (anticlockwise) mode
// * `g`: global output gain between 0 and 1
//-----------------------------
decoderStereo2(n, cw, g) = thisStereoDecoder
	with {
			//d is direct mode (1) or indirect mode (-1)
			//g is the absolute gain
			leftDispatcher = _<:(*(1-cw), *(cw));
			rightDispatcher = _<:(*(cw), *(1-cw));
			thisStereoDecoder =  ho.decoderStereo(n) : (*(g), *(g)) : (leftDispatcher, rightDispatcher) :> (_, _);
};

//-------`(mm.)2dIrregularDecoder`----------
// Irregular decoder in 2D

// `irregularDecoder` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : irregularDecoder(n,d,g) : _,_,...
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 inputs to the 2dstereodecoder function)
// * `la' : the list of angles, for instance (0, 85, 175, 275) for four loudspeakers
//-----------------------------
irregularAngleDecoder(n, la) = par(i, 2*n+1, _) <: par(i, p, speaker(n, ba.take(i+1, la)))
	with {
			p = outputs(la);
   			speaker(n,alpha) = /(2), par(i, 2*n, _), ho.encoder(n,2/(2*n+1),alpha) : si.dot(2*n+1);
};

//-------`(ho.)decoder2`----------
// Ambisonic irregular decoder (irregular angles) in 2D enabling to use either a stereo configuration or a multi-loudspeaker configuration

// `decoderStereo2` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : decoder2(n, la, cw, st, g) : _,_
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 inputs to the decoder2_ui function)
// * 'la': the list of angles
// * 'cw': 1 for direct (clockwise) mode, -1 for the indirect (anticlockwise) mode
// * 'st': 1 for stereo, 0 for multi-loudspeaker configuration. When 1, stereo sounds goes through the first two channels
// * 'g' : gain between 0 and 1
//-----------------------------
decoder2(n, la, cw, st, g) = thisDecoder
	with {
			//p is the number of outputs
            p = outputs(la);
			ambi = 1 - st;
			//
			//for stereo decoding
			paddedStereoDecoder(n, p) = (decoderStereo2(n, cw, g), (0 <: si.bus(p-2)));
			//
			thisDecoder = si.bus(2*n+1) <: (si.bus(2*n+1), si.bus(2*n+1)) : (irregularAngleDecoder(n, la), paddedStereoDecoder(n, p)) : (par(i, p, *(ambi)), *(st), *(st), si.bus(p-2))  :> si.bus(p) : abc_gainline(p, g);
};


//-------`(ho.)optim`----------
// Ambisonic optimizer including the three elementary optimizers:
// - (ho).optimBasic, (ho).optimMaxRe, (ho.)optimInPhase
//----------------`optimBasic`-------------------------
//The basic optimization has no effect and should be used for a perfect 
//circle of loudspeakers with one listener at the perfect center loudspeakers 
//array.
//----------------`optimMaxRe`-------------------------
//The maxRe optimization optimize energy vector. It should be used for an 
//auditory confined in the center of the loudspeakers array.
//----------------`optimInPhase`-------------------------
//The inPhase Optimization optimize energy vector and put all loudspeakers signals 
//in phase. It should be used for an auditory.

// `optim` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_, ... : optim(n, ot) : _,_, ...
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 inputs and outputs to the optim function)
// * 'ot' : optimization type (0 for optimBasic, 1 for optimMaxRe, 2 for optimInPhase)
optim(n, ot) = thisOptimizer
	with {
			optb = (ot == 0) : si.smoo;
			optm = (ot == 1) : si.smoo;
			opti = (ot == 2) : si.smoo;
			interlace(n) = si.bus(2*n) <: par(i, n, (ba.selector(i, 2*n), ba.selector(i+n, 2*n)));
			thisOptimizer = ((si.bus(2*n+1)  <: ((si.bus(2*n+1):ho.optimBasic(n)), (si.bus(2*n+1):ho.optimMaxRe(n)), (si.bus(2*n+1):ho.optimInPhase(n)))), ((optb <: si.bus(2*n+1)), (optm <: si.bus(2*n+1)), (opti <: si.bus(2*n+1)))) : interlace(6*n+3) : par(i, 6*n+3, *) :> si.bus(2*n+1);
};

//-------`(ho.)mirror`----------
// Mirroring effect on the sound field

// `mirror` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_, ... : mirror(n, fa) : _,_, ...
// ```
//
// Where:
//
// * `n`: the ambisonic order (there are 2*n+1 inputs and outputs to the mirror function)
// * 'fa' : mirroring type (1=original sound field; 0=original+mirrored sound field; -1=mirrored sound field)
mirror(n, fa) = (*(1), par(i, n, (*(fa), *(1))));

fxDecorrelation(n, d, f, fa, fd, tf) = par(i, 2*n+1, gate(d, i, 2*n+1, fa, tf, f, fd))
			with {
                gate(d, i, n, fa, tf, f, fd) = _ <: fdOverlappedDelay(dur(d, i, n, fa, tf), 262144, f, fd) * env1(fa, i, n), _ * env1c(fa, i, n) : + ;
				//
				fdOverlappedDelay(nsamp, nmax, freq, fdbk) = (+ : de.sdelay(nmax, int(ma.SR / freq), nsamp)) ~ (*(fdbk));
                //
                env1(fa, i, n) = (fa > ((n-i-1)/n)) : si.smooth(ba.tau2pole(0.005));
                env1c(fa, i, n) = 1 - env1(fa, i, n);
                //
				//computes the ith duration of the ith delay in samples with twenty two possibilities of distribution
				elemdur(d, i, p, fa, tf, ind) = (tf == ind) * (fa > (1 - x)) * d * x * fa
					with {
							x = th(ind, i, p);
					};
				//duration in samples computed as a sum of the 22 cases//
				dur(d, i, p, fa, tf) = sum(ind, 22, elemdur(d, i, p, fa, tf, ind)) : int;
};

synDecorrelation(n, d, f, fa, fd, tf) =  _ <: si.bus(2*n+1) : par(i, 2*n+1, crossFade(d, i, 2*n+1, fa, tf, f, fd))
			with {
				crossFade(d, i, n, fa, tf, f, fd) = _ <: fdOverlappedDelay(dur(d, i, n, fa, tf), 262144, f, fd) * env1(fa, i, n), _ * env1c(fa, i, n) :> _ * env2(fa, i, n);
                //
				fdOverlappedDelay(nsamp, nmax, freq, fdbk) = (+ : de.sdelay(nmax, int(ma.SR / freq), nsamp)) ~ (*(fdbk));
				//
                env1(fa, i, n) = (fa > ((n-i-1)/n)) : si.smooth(ba.tau2pole(0.005));
				env1c(fa, i, n) = 1 - env1(fa, i, n) ; 
				env2(fa, i, n) = ((i > 0) * n * min(fa, 1/n)) + ((i == 0) * (sqrt(n) * (1 - (n - sqrt(n)) * min(fa, 1/n)))) : si.smooth(ba.tau2pole(0.005));
                //
				//computes the ith duration of the ith delay in samples with twenty two possibilities of distribution
				elemdur(d, i, p, fa, tf, ind) = (tf == ind) * fa * d * x
					with {
							x = th(ind, i, p);
					};
				//duration in samples computed as a sum of the 22 cases//
				dur(d, i, p, fa, tf) = sum(ind, 22, elemdur(d, i, p, fa, tf, ind)) : int;
};

//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//UTILITY FUNCTIONS USED IN SEVERAL OTHER FUNCTIONS//TYPES OF DISTRIBUTIONS: 22 FUNCTIONS FROM [0, 1] to [0,1]
//(i+1)/p belongs to [0, 1] and its image by any function also belongs to the interval
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
th(0, i, p) = (i+1) / p;
th(1, i, p) = ((i+1) / p)^2;
th(2, i, p) = sin(ma.PI * 0.5 * (i+1) / p);
th(3, i, p) = log10(1 + (i+1) / p) / log10(2);
th(4, i, p) = sqrt((i+1) / p);
th(5, i, p) = 1 - cos(ma.PI * 0.5 * (i+1) / p);
th(6, i, p) = (1 - cos(ma.PI * (i+1) / p)) * 0.5;
th(7, i, p) = 1 - (1 - (i+1) / p )^2;
th(8, i, p) = ((i+1) / p < 0.5) * 2 * ((i+1) / p)^2 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^2 * 0.5) ;
th(9, i, p) = ((i+1) / p)^3 ;
th(10, i, p) = 1 - (1 - (i+1) / p)^3 ;
th(11, i, p) = ((i+1) / p < 0.5) * 4 * ((i+1) / p)^3 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^3 * 0.5) ;
th(12, i, p) = ((i+1) / p)^4 ; 
th(13, i, p) = 1 - (1 - (i+1) / p)^4 ;
th(14, i, p) = ((i+1) / p < 0.5) * 8 * ((i+1) / p)^4 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^4 * 0.5) ;
th(15, i, p) = ((i+1) / p)^5 ; 
th(16, i, p) = 1 - (1 - (i+1) / p)^5 ;
th(17, i, p) = ((i+1) / p < 0.5) * 16 * ((i+1) / p)^5 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^5 * 0.5) ;
th(18, i, p) = 2^(10 * (i+1) / p - 10) ;
th(19, i, p) = ((i+1) / p < 1) * (1 - 2^(-10 * (i+1) / p)) + ((i+1) / p == 1) ;
th(20, i, p) = 1 - sqrt(1 - ((i+1) / p)^2) ; 
th(21, i, p) = sqrt(1 - ((i+1) / p - 1)^2) ;