//--------------------------------------------------------------------------------------//
//----------------------------------------abclib----------------------------------------//
//
//-------------------------FAUST CODE AND UTILITIES FOR MIXED MUSIC---------------------//
//
//-----------------------BY ALAIN BONARDI & PAUL GOUTMANN - 2019-2021 ------------------//
//---------------------CICM - MUSIDANSE LABORATORY - PARIS 8 UNIVERSITY-----------------//
//--------------------------------------------------------------------------------------//
//
declare author "Alain Bonardi & Paul Goutmann";
declare licence "LGPLv3";
declare name "abclib";
//
import("stdfaust.lib");
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//MAIN PROCESSES OF THE ABCLIB LIBRARY WITH THEIR CONTROL INTERFACE
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//AMBISONIC DECODERS: STEREO AND IRREGULAR (general decoder includes both modes)
//--------------------------------------------------------------------------------------//
//
abc_2d_toStereo(n, d, g) = thisStereoDecoder
	with {
			//d is direct mode (1) or indirect mode (-1)
			//g is the absolute gain
			leftDispatcher = _<:(*(1-d), *(d));
			rightDispatcher = _<:(*(d), *(1-d));
			thisStereoDecoder =  ho.decoderStereo(n) : (*(g), *(g)) : (leftDispatcher, rightDispatcher) :> (_, _);
}; 

abc_2d_stereoDecoder(n) = abc_2d_toStereo(n, direct, gain)
	with {
			direct = 2 * nentry("v:stereodecoder/directangles", 1, 0, 1, 1) - 1;
			gain = hslider("v:stereodecoder/gain [unit:dB]", 0, -127, 18, 0.01) : abc_dbcontrol;
};

abc_2d_decoder(n, p) = thisDecoder
	with {
			direct = 2 * nentry("v:decoder/directangles", 1, 0, 1, 1) - 1; 
			offset = hslider("v:decoder/angularoffset [unit:deg]", 0, -180, 180, 1) * ma.PI / 180;
			gain = hslider("v:decoder/gain [unit:dB]", 0, -127, 18, 0.01) : abc_dbcontrol;
			a(ind, nls) = (hslider("v:decoder/a%2ind [unit:deg]", ind * 360 / nls, -360, 360, 1) * ma.PI / 180. - direct * offset) : *(direct) : si.smoo;
			stereo = nentry("v:decoder/stereo", 0, 0, 1, 1) : si.smoo;
			ambisonic = 1 - stereo;
			//
			gainLine(n) = par(i, n, *(gain));
			//
			//basic irregular decoder
			//
			basicIrregularDecoder(n, p) = par(i, 2*n+1, _) <: par(i, p, speaker(n, a(i,p)))
			with {
   					speaker(n,alpha) = /(2), par(i, 2*n, _), ho.encoder(n,2/(2*n+1),alpha) : si.dot(2*n+1);
			};
			//
			//for stereo decoding
			basicStereoDecoder(n, p) = (abc_2d_toStereo(n, direct, gain), (0 <: si.bus(p-2)));
			//
			thisDecoder = abc_busduplicate(2*n+1) : (basicIrregularDecoder(n, p), basicStereoDecoder(n, p)) : (par(i, p, *(ambisonic)), *(stereo), *(stereo), si.bus(p-2))  :> si.bus(p) : gainLine(p);
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC ENCODER WITH ROTATION OR STATIC MODES
//--------------------------------------------------------------------------------------//
//
abc_2d_encoder(n) = thisEncoder
	with {
			rotfreq = hslider("v:encoder/speed [unit:s-1]", 0, -100, 100, 0.001);
			rotphase = hslider("v:encoder/angle [unit:deg]", 0, -360, 360, 0.01) / 360;
			returntime = hslider("v:encoder/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
			//
			myEncoder(sig, angle) = ho.encoder(n, sig, angle);//at ambisonic order n
			//
			freqPhaseEncoder(f, p, dt) = (_, abc_rotationOrStaticAngle(f, p, dt)) : myEncoder;
			//
			thisEncoder = freqPhaseEncoder(rotfreq, rotphase, returntime);
};
//
//--------------------------------------------------------------------------------------//
//2D MAPS
//--------------------------------------------------------------------------------------//
//
abc_2d_map(n) = thisMap
	with {
		thisMap(sig, r, a) = ho.encoder(n, sig * volume(r), a) : ho.wider(n, ouverture(r))
			with {
				volume(r) = 1. / (r * r * (r > 1) + (r <= 1));
				ouverture(r) = r * (r <= 1) + (r > 1);
			};
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC MIRROR WITH FACTOR
//--------------------------------------------------------------------------------------//
//
//FX MIRROR APPLIES A FACTOR AS A WEIGHT TO THE NEGATIVE HARMONICS
//TO CREATE THE MIRROR SOUNDFIELD TO ITSELF
//
//H					WEIGHT
//0					1				
//-1				FACTOR				
//1					1				
//-2				FACTOR				
//2					1				
//...
//-(N-1)			FACTOR
//(N-1)				1			
//-N				FACTOR
//N					1				
//
//THE FACTOR CAN TAKE 3 VALUES:
//1 => ORIGINAL SOUND FIELD
//0 => ORIGINAL + MIRROR SOUND FIELD
//-1 => MIRROR SOUND FIELD
//--------------------------------------------------------------------------------------//
abc_2d_mirror(n) = (*(1), par(i, n, (*(factor), *(1))))
		with {
			factor = hslider("factor", 1, -1, 1, 1) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC OPTIMIZATION WITH OPTIM TYPE
//--------------------------------------------------------------------------------------//
//
//A COMBINED OPTIMIZATION FUNCTION ENABLING THREE MODES OF OPTIMIZATION:
//-basic
//-maxRe
//-inPhase
//----------------`optimBasic`-------------------------
//The basic optimization has no effect and should be used for a perfect 
//circle of loudspeakers with one listener at the perfect center loudspeakers 
//array.
//----------------`optimMaxRe`-------------------------
//The maxRe optimization optimize energy vector. It should be used for an 
//auditory confined in the center of the loudspeakers array.
//----------------`optimInPhase`-------------------------
//The inPhase Optimization optimize energy vector and put all loudspeakers signals 
//in phase. It should be used for an auditory.
//--------------------------------------------------------------------------------------//
abc_2d_optim(n) = thisoptimizer
		with {
			optimtype = nentry("optimtype", 0, 0, 2, 1);
			thisoptimizer = ((si.bus(2*n+1)  <: ((si.bus(2*n+1):ho.optimBasic(n)), (si.bus(2*n+1):ho.optimMaxRe(n)), (si.bus(2*n+1):ho.optimInPhase(n)))), (((optimtype == 0) <: si.bus(2*n+1)), ((optimtype ==1) <: si.bus(2*n+1)), ((optimtype == 2) <: si.bus(2*n+1)))) : abc_interlace2(6*n+3) : par(i, 6*n+3, *) :> si.bus(2*n+1);
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC SOUND FIELD ROTATION
//--------------------------------------------------------------------------------------//
//
abc_2d_rotate(n) = thisrotate
		with {
			rotfreq = hslider("v:rotate/speed [unit:s-1]", 0, -100, 100, 0.001);
			rotphase = hslider("v:rotate/angle [unit:deg]", 0, -360, 360, 0.01) / 360;
			returntime = hslider("v:rotate/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
			//
			thisrotate =  ho.rotate(n, abc_rotationOrStaticPhase(rotfreq, rotphase, returntime));
};
//
//--------------------------------------------------------------------------------------//
//SCOPE OBJECTS FOR AMBISONIC VIZUALISATION USING XY SCOPE OBJECTS
//--------------------------------------------------------------------------------------//
//
abc_2d_scope(n) = thisscope
		with {
			//Control parameter: number of complete cycles (complete drawings) per second
			refresh = hslider("v:scope/refresh [unit:msec]", 10, 1, 2000, 1) * 0.001;//refresh time, default is 10 msec
			//Angle sweeping at a speed corresponding to refresh period between 0 and 2*PI
			theta = os.phasor(1, 1/refresh) * 2 * ma.PI;
			//we get the vector of harmonic functions thanks to the encoding function//
			harmonicsVector = ho.encoder(n, 1, theta);
			//building (2n+1) normalized vectors
			inputVector = (*(0.5), par(i, (2*n), _)) : abc_normalizedvector(2*n+1);
			normalizedHarmonics = harmonicsVector : abc_normalizedvector(2*n+1);
			//
			rho = (inputVector, normalizedHarmonics) : si.dot(2*n+1);
			thisscope = (rho <: (ma.fabs, (_ >= 0))) : ((_ <: (_, _)), _) : (*(sin(theta)), *(cos(theta)), _) : (*(-1), _, _);
};
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//2D SPATIAL TRAJECTORIES
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//2D SQUARE TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_square(f, s) = os.phasor(1,f) : *(2 * ma.PI) <: (cos, sin) : (*(sqrt(2)), *(sqrt(2))) : (abc_clip, abc_clip) : (*(s), *(s)) : (*(-1), *(1));
//
abc_2d_squareTrajectory = abc_2d_square(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D Z TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_z(f, s) = os.phasor(1, f) <: (x,  y) : (*(s), *(s))
		with {
			x(t) = (t < 0.25) * (-1 + t * 8) + (t >= 0.25) * (t < 0.5) * (1 - (t - 0.25)*8) + (t >= 0.5) * (t < 0.75) * (-1 + (t - 0.5) * 8) + (t >= 0.75) * (1 - (t - 0.75) * 8);
			y(t) = (t < 0.25) * (1) + (t >= 0.25) * (t < 0.5) * (1 - (t - 0.25) * 8) + (t >= 0.5) * (t < 0.75) * (-1) + (t >= 0.75) * (-1 + (t - 0.75) * 8);
};
//
abc_2d_zTrajectory = abc_2d_z(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D RANDOM TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_random_xy(f, s) = thisRandomPos
		with {
			ramp = os.phasor(1, f);
			th = (ramp > 0.001) * (ramp@1 <= 0.001);
			temporalFilter = ba.sAndH(th);
			//computes the temporal interval taking into account the case when f=0 and when f<0
			dt = (1000., ba.if(f==0, 0.00001, f)) : / : ma.fabs ;
			p(a, b, c, d) = (a, c, b, d);
			thisRandomPos = (no.multinoise(2), dt, dt) : (temporalFilter, temporalFilter, _, _) : (*(s), *(s), _, _) : p : (abc_line, abc_line);
};
abc_2d_randomTrajectory = abc_2d_random_xy(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D SQUARE AND Z TRAJECTORIES
//--------------------------------------------------------------------------------------//
//
abc_2d_squareZ(f, s, cf) = (abc_2d_square(f, s), abc_2d_z(f,s)) : (*(1-cf), *(1-cf), *(cf), *(cf)) : abc_interlace2(2) : (+, +);
//
abc_2d_squareAndZTrajectory = abc_2d_squareZ(freq, size, crossfade)
			with {
				freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
				size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
				crossfade = hslider("v:trajectory/crossfade", 0, 0, 1, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//SYN AND FX DECORRELATION PROCESSES
//--------------------------------------------------------------------------------------//
//
//SYN DECORRELATION GENERATES SPATIAL DECORRELATED COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES DECORRELATIONS TO SPATIAL COMPONENTS ALREADY CREATED
//THE DECORRELATION IS DEFINED FOR EACH SPATIAL COMPONENT AMONG P=2*N+1 AT THE AMBISONIC ORDER N
//AS A DELAY OF 0 IF FACTOR IS UNDER A CERTAIN VALUE 1-(i+1)/P AND DELAY*F((i+1)/P) IN THE CONTRARY CASE
//THE USER CAN CHOOSE THE TYPE OF DELAY TIME DISTRIBUTION AMONG 22 DIFFERENT DISTRIBUTIONS
//AS IN SYN OR FX DELAY THE DELAY INCREASES ACCORDING TO THE INDEX OF COMPONENTS
//BUT IT INCREASES AT EACH STEP AND IT IS MODULATED BY A THRESHOLD
//THEREFORE DELAYS ARE PROGRESSIVELY REVEALED WHEN THE FACTOR INCREASES
//WHEN THE FACTOR IS CLOSE TO 0, ONLY UPPER COMPONENTS ARE DELAYED
//WHEN THE FACTOR INCREASES, MORE AND MORE COMPONENTS ARE DELAYED
//
//H					THRESHOLD			DELAY
//0					1-1/P				0 OR DELAY*F(1/P)
//-1				1-2/P				0 OR DELAY*F(2/P)
//1					1-3/P				0 OR DELAY*F(3/P)
//-2				1-4/P				0 OR DELAY*F(4/P)
//2					1-5/P				0 OR DELAY*F(5/P)
//...
//-(N-1)			1-(P-3)/P			0 OR DELAY*F((P-3)/P)
//(N-1)				1-(P-2)/P			0 OR DELAY*F((P-2)/P)
//-N				1-(P-1)/P			0 OR DELAY*F((P-1)/P)
//N					1-P/P				0 OR DELAY*F(P/P)
//
//THE PURPOSE IS TO EXPLORE TEMPORAL DECORRELATION BETWEEN SPATIAL COMPONENTS
//EITHER BY CREATING P DELAYED COPIES OF THE INCOMING SIGNAL (SYN DELAY)
//OR BY ADDING DELAYS TO THE ALREADY EXISTING P SPATIAL COMPONENTS
//
//--------------------------------------------------------------------------------------//
//fx decorrelation process
//--------------------------------------------------------------------------------------//
abc_2d_fx_decorrelation(n) = thisfxdecorrelator 
	with {
		delay = hslider("v:synfxdecorrelation/delay [unit:samples]", 48000, 10, 262144, 1);
		window = 100; //by default a window of 100 milliseconds for the interpolation of delays//
		winfreq = 1000. / window;
		factor = hslider("v:synfxdecorrelation/factor", 0, 0, 1, 0.001);
		fdbk = hslider("v:synfxdecorrelation/fdbk", 0, 0, 0.99, 0.001);
		functiontype = hslider("v:synfxdecorrelation/functiontype", 0, 0, 21, 1);
		//
		fxdecorrelation(n, d, f, fa, fd, tf) = par(i, n, abc_fdOverlappedDoubleDelay(dur(d, i, n, fa, tf), 262144, f, fd))
			with {
				//computes the ith duration of the ith delay in samples with twenty two possibilities of distribution
				elemdur(d, i, p, fa, tf, ind) = (tf == ind) * (fa > (1 - x)) * d * x
					with {
							x = abc_th(ind, i, p);
					};
					//duration in samples computed as a sum of the 22 cases//
				dur(d, i, p, fa, tf) = sum(ind, 22, elemdur(d, i, p, fa, tf, ind)) : int;

		};
		thisfxdecorrelator = fxdecorrelation(n, delay, winfreq, factor, fdbk, functiontype);
};
//
//--------------------------------------------------------------------------------------//
//syn decorrelation process
//--------------------------------------------------------------------------------------//
abc_2d_syn_decorrelation(n) = _ <: si.bus(n) : abc_2d_fx_decorrelation(n);
//
//
//--------------------------------------------------------------------------------------//
//SYN AND FX DELAY PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN DELAY GENERATES SPATIAL DELAYED COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES DELAYS TO SPATIAL COMPONENTS ALREADY CREATED
//THE 2*N+1 DELAYS ARE EQUALLY SPREAD BETWEEN DELTIME/(N+1) AND DELTIME WHICH IS THE MAXIMUM
//H0 HAS A DELAY OF DELTIME/N, H-1 AND H1 OF 2*DELTIME/N, ETC.
//
//H					DELAY
//0					DELTIME/(N+1)
//-1 & 1			2*DELTIME/(N+1)
//-2 & 2			3*DELTIME/(N+1)
//-3 & 3			4*DELTIME/(N+1)
//...
//-(N-1)& (N-1)		N*DELTIME/(N+1)
//-N & N			DELTIME	
//
//THE PURPOSE IS TO EXPLORE TEMPORAL DECORRELATION BETWEEN SPATIAL COMPONENTS
//EITHER BY CREATING P DELAYED COPIES OF THE INCOMING SIGNAL (SYN DELAY)
//OR BY ADDING DELAYS TO THE ALREADY EXISTING P SPATIAL COMPONENTS
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx delay process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_delay(n) = thisfxdelay
	with {
		window = hslider("v:synfxdelay/window [unit:msec]", 400, 10, 1000, 1);
		winfreq = 1000. / window;
		deltime = hslider("v:synfxdelay/deltime [unit:msec]", 100, 2, 10000, 0.01);
		feedback = hslider("v:synfxdelay/feedback", 0, 0, 1, 0.001) :  si.smoo;
		//
		durToSamp(d, i, p) = d * 2 / (p+1) * (1 + int((i+1)/2)) * 0.001 * ma.SR;
		//
		thisfxdelay = par(i, n, abc_fdOverlappedDoubleDelay(durToSamp(deltime, i, n), 524288, winfreq, feedback));
};
//
//--------------------------------------------------------------------------------------//
//syn delay process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_delay(n) = _ <: si.bus(n) : abc_2d_fx_delay(n);
//
//--------------------------------------------------------------------------------------//
//SYN AND FX GRAIN PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN GRAIN GENERATES SPATIAL GRANULAR COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES GRANULAR TRANSFORMATION TO SPATIAL COMPONENTS ALREADY CREATED
//AT AMBISONIC ORDER N, THERE ARE 2*N+1 GRANULATORS, BEING TEMPORALLY CONTROLLED
//BY 2 PARAMETERS: THE GRAIN SIZE GS AND THE MAX DELAY D
//WE HAVE THE FOLLOWING DISPATCHING
//H					GRAINSIZE				MAXDELAY
//0					GS						0
//-1 & 1			GS - GS/(N+1)			D/(N+1)
//-2 & 2			GS - GS*2/(N+1)			2*D/(N+1)
//-3 & 3			GS - GS*3/(N+1)			3*D/(N+1)
//...
//-(N-1) & (N-1)	GS - GS*(N-1)/(N+1)		(N-1)*D/(N+1)
//-N & N			GS - GS*N/(N+1)			N*D/(N+1)
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx grain process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_grain(n) = thisfxgrain
	with {
		grainsize = hslider("v:synfxgrain/grainsize [unit:msec]", 400, 2, 3000, 1);
		deltime = hslider("v:synfxgrain/deltime [unit:msec]", 100, 2, 5000, 0.01);
		feedback = hslider("v:synfxgrain/feedback", 0, 0, 1, 0.001) :  si.smoo;
		rarefaction = hslider("v:synfxgrain/rarefaction", 0.5, 0, 1, 0.001);
		//
		dur(d, i, p) = d * 2 / (p+1) * (int((i+1)/2)); //max delays in milliseconds for each spatial component
		gsize(gs, i, p) = gs - int((i+1) / 2) * gs * 2 / (p+1); //grain sizes in milliseconds for each spatial component
		thisfxgrain = ((no.multinoise(2*n), (si.bus(2*n) :> si.bus(n))) : abc_interlace3(n) : par(i, n, abc_granulator(gsize(grainsize, i, n), dur(deltime, i, n), rarefaction))) ~ (par(i, n, *(feedback)));
};
//
//--------------------------------------------------------------------------------------//
//syn grain process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_grain(n) = thissyngrain
	with {
		grainsize = hslider("v:synfxgrain/grainsize [unit:msec]", 400, 2, 3000, 1);
		deltime = hslider("v:synfxgrain/deltime [unit:msec]", 100, 2, 5000, 0.01);
		feedback = hslider("v:synfxgrain/feedback", 0, 0, 1, 0.001) :  si.smoo;
		rarefaction = hslider("v:synfxgrain/rarefaction", 0.5, 0, 1, 0.001);
		//
		dur(d, i, p) = d * 2 / (p+1) * (int((i+1)/2)); //max delays in milliseconds for each spatial component
		gsize(gs, i, p) = gs - int((i+1) / 2) * gs * 2 / (p+1); //grain sizes in milliseconds for each spatial component
		thissyngrain = ((no.multinoise(2*n), (((_, _) : +) <: si.bus(n))) : abc_interlace3(n)  : par(i, n, abc_granulator(gsize(grainsize, i, n), dur(deltime, i, n), rarefaction))) ~ (par(i, n, _) :> *(feedback));
};
//
//
//--------------------------------------------------------------------------------------//
//SYN AND FX RINGMODULATION PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN RINGMOD GENERATES SPATIAL COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL THANKS TO RING MODULATION
//FX RINGMOD APPLIES RING MODULATION TO SPATIAL COMPONENTS ALREADY CREATED
//THE RING MODULATION IS DEFINED FOR EACH SPATIAL COMPONENT AMONG P=2*N+1 AT THE AMBISONIC ORDER N
//FOR EACH SPATIAL COMPONENT #i, THE RESULT IS EITHER THE ORIGINAL SIGNAL OR A RING MODULATED SIGNAL
//ACCORDING TO A THRESHOLD WHICH IS i/P.
//THE GENERAL PROCESS IS DRIVEN BY A FACTOR BETWEEN 0 AND 1 AND A MODULATION FREQUENCY F0
//IF FACTOR IS UNDER THE THRESHOLD i/P, THE ith RING MODULATOR OUTPUTS 0 (TO LET THE ORIGINAL SIGNAL),
//IN THE CONTRARY IT WORKS AS A REAL RING MODULATOR WITH A MODULATION FREQUENCY OF F0*i/P
//THEREFORE RING MODULATORS ARE PROGRESSIVELY REVEALED WHEN THE FACTOR INCREASES
//
//H					THRESHOLD			OUTPUT
//0					1/P					ORIGINAL OR RING MODULATION BY F0*1/P
//-1				2/P					ORIGINAL OR RING MODULATION BY F0*2/P
//1					3/P					ORIGINAL OR RING MODULATION BY F0*3/P
//-2				4/P					ORIGINAL OR RING MODULATION BY F0*4/P
//2					5/P					ORIGINAL OR RING MODULATION BY F0*5/P
//...
//-(N-1)			(P-3)/P				ORIGINAL OR RING MODULATION BY F0*(P-3)/P
//(N-1)				(P-2)/P				ORIGINAL OR RING MODULATION BY F0*(P-2)/P
//-N				(P-1)/P				ORIGINAL OR RING MODULATION BY F0*(P-1)/P
//N					P/P=1				ORIGINAL OR RING MODULATION BY F0*P/P=F0
//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx ringmod process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_ringmod(n) = thisfxringmod
	with {
		f0 = hslider("v:synfxringmod/f0 [unit:Hz]", 10, 0, 10000, 0.0001);
		factor = hslider("v:synfxringmod/factor", 0, 0, 1, 0.001);
		//
		ambi_ringmod(f, i, n, fa) = _ <: (*(os.osccos(ringmodfreq(f, i, n))), _) : (*(c), *(1-c)) : +	
			with {
				c = (fa >= ((i+1)/n)) : si.smooth(ba.tau2pole(0.005));
				ringmodfreq(f, i, n) = f * (i+1) / n;
		};
		thisfxringmod = par(i, n, ambi_ringmod(f0, i, n, factor));
};
//
//--------------------------------------------------------------------------------------//
//syn ringmod process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_ringmod(n) = _ <: si.bus(n) : abc_2d_fx_ringmod(n);
//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//UTILITY FUNCTIONS USED IN SEVERAL OTHER FUNCTIONS, WITH NO INTERFACE
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//DOUBLE OVERLAPPED DELAY
//--------------------------------------------------------------------------------------//
//
//A double overlapped delay without reinjection//
//--------------------------------------------------------------------------------------//
abc_overlappedDoubleDelay(nsamp, nmax, freq) = doubleDelay
	with {
			pdPhasor(f) = os.phasor(1, f);
			env1 = freq : pdPhasor : abc_sinusEnvelop : *(0.5) : +(0.5);
			env1c = 1 - env1;
			th1 = (env1 > 0.001) * (env1@1 <= 0.001); //env1 threshold crossing
			th2 = (env1c > 0.001) * (env1c@1 <= 0.001); //env1c threshold crossing
			nsamp1 = nsamp : ba.sAndH(th1);
			nsamp2 = nsamp : ba.sAndH(th2);
			doubleDelay =	_ <: (de.delay(nmax, nsamp1), de.delay(nmax,nsamp2)) : (*(env1), *(env1c)) : + ;
		};
//
//A double overlapped delay with reinjection//
//--------------------------------------------------------------------------------------//
abc_fdOverlappedDoubleDelay(nsamp, nmax, freq, fd) = (+ : abc_overlappedDoubleDelay(nsamp, nmax, freq)) ~ (*(fd));
//
//
//--------------------------------------------------------------------------------------//
// MAX LIKE AND PUREDATA LIKE BIQUADS + HILBERT FILTER + FREQUENCY SHIFTERS
//--------------------------------------------------------------------------------------//
//
//A max like biquad
//y[n] = a0 * x[n] + a1 * x[n-1] + a2 * x[n-2] - b1 * y[n-1] - b2 * y[n-2]
//--------------------------------------------------------------------------------------//
abc_maxLikeBiquad(x,a0,a1,a2,b1,b2)  =  x : + ~ ((-1)*conv2(b1, b2)) : conv3(a0, a1, a2) 
	with {
		conv2(c0,c1,x) = c0*x+c1*x';
		conv3(c0,c1,c2,x) = c0*x+c1*x'+c2*x'';
	};
//
//A PureData like biquad
//in direct form 2
//--------------------------------------------------------------------------------------//
abc_pdLikeBiquad(x, c_fb1, c_fb2, c_ff1, c_ff2, c_ff3) = abc_maxLikeBiquad(x, ff1, ff2, ff3, fb1, fb2) 
	with {
		//first, compute the stability of the biquad//	
		discriminant = c_fb1*c_fb1 + 4 * c_fb2;
		condition1 = ((discriminant < 0) & (c_fb2 >= -1.0));
		condition2 = ((discriminant >= 0) & (c_fb1 >= -2.0) & (c_fb1 <= 2.0) & (c_fb1+c_fb2 <= 1.0) & (c_fb1-c_fb2 >= -1.0));
		stable = (condition1 | condition2);//stable is 0 (unstable) or 1 (stable)		
		//second the final coefficients to apply to biquad that is defined in maxmsp.lib//
		fb1 = c_fb1 : *(stable) : (*(-1.));
		fb2 = c_fb2 : *(stable) : (*(-1.));
		ff1 = c_ff1 : *(stable);	
		ff2 = c_ff2 : *(stable);	
		ff3 = c_ff3 : *(stable);
	};
//
//Hilbert filter
//--------------------------------------------------------------------------------------//
abc_hilbertFilter = _ <: (biquad1, biquad3) : (biquad2, biquad4)
	with {
			biquad1(x) = abc_pdLikeBiquad(x, -0.02569, 0.260502, -0.260502, 0.02569, 1.);
			biquad2(x) = abc_pdLikeBiquad(x, 1.8685, -0.870686, 0.870686, -1.8685, 1.);
			biquad3(x) = abc_pdLikeBiquad(x, 1.94632, -0.94657, 0.94657, -1.94632, 1.);
			biquad4(x) = abc_pdLikeBiquad(x, 0.83774, -0.06338, 0.06338, -0.83774, 1.);
	};
//
//frequency shifter definition
//1 inlet, 2 outlets : +f0 outlet and -f0 outlet
//--------------------------------------------------------------------------------------//
abc_fshift(freq) = hilbertByCosAndMinusSin <: (+, -)
	with {
		//cosinus enveloppe//
		osc1 = *(-1) : +(0.25) : ma.frac : abc_sinusEnvelop;
		//permutation//
		p1(a, b, c, d) = (a, c, b, d);
		cosAndMinusSin = os.phasor(1, freq) <: (_, +(0.25)) : (osc1, osc1);
		hilbertByCosAndMinusSin = (hilbertFilter, cosAndMinusSin) : p1 : (*, *);
};
//
//We define specific fshift with only pos or neg output//
//--------------------------------------------------------------------------------------//
abc_fshiftp(freq) = fshift(freq) : (_, !);
abc_fshiftn(freq) = fshift(freq) : (!, _);
//
//
//--------------------------------------------------------------------------------------//
//GRANULATOR ON DELAY LINE WITH GS GRAIN SIZE, D AS MAXIMUM DELAY, S AS RAREFACTION
//USES A COSINUS ENVELOP
//--------------------------------------------------------------------------------------//
//
abc_granulator(gs, d, s) = (_, _, _) : (env, _, del) : (_, de.delay(262144, _)) : *
	with {
			//gs is the grain size in milliseconds//
			//d is the max delay in milliseconds//
			//s is the rarefaction between 0 and 1//
			//the capacity of storage of the delay line is 262144 which is roughly 5,46 sec of delay at 48KHz
			f = 1000. / gs; //f is the frequency of the grain
			ramp = os.phasor(1, f);
			th = (ramp > 0.001) * (ramp@1 <= 0.001);
			randTest = (_, (s : *(2) : -(1))) : >;
			factor = randTest : ba.sAndH(th);
			env = ((ramp : *(0.5) : abc_sinusEnvelop), _) : *(factor);
			del = +(1) : *(0.5) : *(d) : *(0.001) : *(ma.SR) : int : ba.sAndH(th);
		};		 
//
//--------------------------------------------------------------------------------------//
//AMPLITUDE CONTROL IN DB
//--------------------------------------------------------------------------------------//
//
//A dB to linear conversion with threshold (-127)
//
abc_dbcontrol = _ <: ((_ > -127.0), ba.db2linear) : *;
//
//
//Amplitude control with gain in dB C
//
abc_dbtogain = si.smoo : abc_dbcontrol;
//
//--------------------------------------------------------------------------------------//
//STATIC OR ROTATION PHASE BETWEEN 0 AND 1 + CORRESPONDING ANGLE IN RADIANS
//--------------------------------------------------------------------------------------//
//
//A phase generator between 0 and 1, with frequency of rotation and static position
//--------------------------------------------------------------------------------------//
abc_rotationOrStaticPhase(f, p, dt) = (1-vn) * x + vn * p
with {
		//f is the frequency of rotation
		//p the position if f values zero
		//dt is the interpolation time between the two situations (static / rotation)
		vn = (f == 0) : si.smooth(ba.tau2pole(dt));
		//to manage the case where frequency is zero, smoothly switches from one mode to another//
		x = (os.phasor(1, f), p, 1) : (+, _) : fmod;
};
//
//The corresponding generator as an angle in radians
//--------------------------------------------------------------------------------------//
abc_rotationOrStaticAngle(f, p, dt) = abc_rotationOrStaticPhase(f, p, dt) * 2 * ma.PI;
//
//--------------------------------------------------------------------------------------//
//LINES AND DRIVE LINES
//--------------------------------------------------------------------------------------//
//
// Implementation of Max/MSP line~. Generate signal ramp or envelope 
// USAGE : line(value, time)
// 	value : the desired output value
//	time  : the interpolation time to reach this value (in milliseconds)
//
// NOTE : the interpolation process is restarted every time the desired
// output value changes. The interpolation time is sampled only then.
//--------------------------------------------------------------------------------------//
abc_line (value, time) = state~(_,_):!,_ 
	with {
		state (t, c) = nt, ba.if (nt <= 0, value, c+(value - c) / nt)
		with {
			nt = ba.if( value != value', samples, t-1);
			samples = time*ma.SR/1000.0;
		};
	};
//
//Definition of a PureData like linedrive object
//--------------------------------------------------------------------------------------//
abc_pdLineDrive(vol, ti, r, f, b, t) = transitionLineDrive
	with {
			//vol = current volume in Midi (0-127)
			//ti = current time of evolution (in msec)
			//r is the range, usually Midi range (127)
			//f is the factor, usually 2
			//b is the basis, usually 1.07177
			//t is the ramp time usually 30 ms

			pre_val = ba.if (vol < r, vol, r);
			val = ba.if (pre_val < 1, 0, f*pow(b, (pre_val - r)));
			pre_ti = ba.if (ti < 1.46, t, ti);
			transitionLineDrive = line(val, pre_ti);
		};
abc_basicLineDrive = (_, 30, 127, 1, 1.06, 30) : abc_pdLineDrive;
abc_pdLineDrive4096 = (_, 30, 127, 4096, 1.07177, 30) : abc_pdLineDrive;
//
//--------------------------------------------------------------------------------------//
//MULTIPLICATION BY 2*PI
//--------------------------------------------------------------------------------------//
abc_mult2pi = *(2. * ma.PI);
//
//--------------------------------------------------------------------------------------//
//PEAKAMP ON N SAMPLES
//--------------------------------------------------------------------------------------//
//
abc_peakamp(n) = maxVal(n) : ba.sAndH(getPeak) with {
	maxVal(n) = (_, abs) ~ (max : *(1 - resetMax)) : (_, !);
	resetMax = ba.pulse(n)@1;
	getPeak = ba.pulse(n);
};
//
//--------------------------------------------------------------------------------------//
//2PI phasor (variation between 0 and 2*PI)
//--------------------------------------------------------------------------------------//
abc_phasor2pi(f) = os.phasor((2. * ma.PI), f);
//
//--------------------------------------------------------------------------------------//
//PLAYER OF A SET OF SAMPLES WITH LINEAR INTERPOLATION
//--------------------------------------------------------------------------------------//
abc_player(f0, mySamp, mySampNum) = thisPlayer with {
	//f0 is the playing frequency
	//mySamp the array of samples
	//mySampNum the number of samples
	zeroToOnePhase =  os.phasor(1, f0) : ma.decimal; 
	myIndex = zeroToOnePhase * float(mySampNum); 
	i1 = int(myIndex);
	i2 = (i1+1) % int(mySampNum);
	d = ma.decimal(myIndex);
	s1 = (mySamp, i1) : (+(1), _, _) : rdtable;
	s2 = (mySamp, i2) : (+(1), _, _) : rdtable;
	thisPlayer = s1 + d * (s2 - s1);
};
//
//--------------------------------------------------------------------------------------//
//POLAR TO CARTESIAN CONVERSION
//angles in radians
//--------------------------------------------------------------------------------------//
//
abc_polar2cartesian = (_, _) <: (_, cos, _, sin) : (*, *);
//
//--------------------------------------------------------------------------------------//
//CARTESIAN TO POLAR CONVERSION
//angles in radians
//--------------------------------------------------------------------------------------//
//
abc_cartesian2polar = permutation <: (module, phase) with {
	permutation(a, b) = (b, a);
	square = _ <: *;
	module = (square, square) : + : sqrt;
	phase = atan2;
};
//
//--------------------------------------------------------------------------------------//
//SINUS ENVELOPE
//--------------------------------------------------------------------------------------//
//
abc_sinusEnvelop(phase) = s1 + d * (s2 - s1)
	with {
			tablesize = 1 << 16;
			sinustable = os.sinwaveform(tablesize);
			zeroToOnePhase = phase : ma.decimal;
			myIndex = zeroToOnePhase * float(tablesize);
			i1 = int(myIndex);
			d = ma.decimal(myIndex);
			i2 = (i1+1) % int(tablesize);
			s1 = rdtable(tablesize, sinustable, i1);
			s2 = rdtable(tablesize, sinustable, i2);
};
//
//--------------------------------------------------------------------------------------//
//INTERLACE FUNCTIONS WITH 2 OR 3 SETS OF SIGNALS
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//starting with 2n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn
//the result is the vector sigA1, sigB1, sigA2, sigB2, ..., sigAn, sigBn
//--------------------------------------------------------------------------------------//
abc_interlace2(n) = si.bus(2*n) <: par(i, n, (ba.selector(i, 2*n), ba.selector(i+n, 2*n)));
//
//--------------------------------------------------------------------------------------//
//starting with 3n values sigA1, sigA2, ... sigAn, sigB1, sigB2, ... sigBn, sigC1, sigC2, ..., sigCn
//the result is the vector sigA1, sigC1, sigB1, sigA2, sigC2, sigB2, ..., sigAn, sigCn, sigBn
//--------------------------------------------------------------------------------------//
abc_interlace3(n) = si.bus(3*n) <: par(i, n, (ba.selector(i, 3*n), ba.selector(i+2*n, 3*n), ba.selector(i+n, 3*n)));
//
//--------------------------------------------------------------------------------------//
//BUS DUPLICATION
//--------------------------------------------------------------------------------------//
//
//starting with n values A1, A2,...An, we want to get A1, A2, ..., An, A1, A2,..., An
abc_busduplicate(n) = si.bus(n) <: (si.bus(n), si.bus(n));
//
//--------------------------------------------------------------------------------------//
//NORMALIZES A VECTOR OF N COMPONENTS
//--------------------------------------------------------------------------------------//
abc_normalizedvector(n) = si.bus(n) <: (si.bus(n), norm) : abc_interlace2(n) : par(i, n, /)
			with {
					norm = par(i, n, _ <:(_,_) : *) :> _ : sqrt <: ((_ == 0), (_ > 0), _) : (_, *) : + <: si.bus(n);
};
//
//--------------------------------------------------------------------------------------//
//CLIP FUNCTION BETWEEN -1 AND 1
//--------------------------------------------------------------------------------------//
abc_clip(x) = (x < -1) * (-1) + (x > 1) + (x >= -1) * (x <= 1) * x;
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//UTILITY FUNCTIONS USED IN SEVERAL OTHER FUNCTIONS//TYPES OF DISTRIBUTIONS: 22 FUNCTIONS FROM [0, 1] to [0,1]
//(i+1)/p belongs to [0, 1] and its image by any function also belongs to the interval
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
abc_th(0, i, p) = (i+1) / p;
abc_th(1, i, p) = ((i+1) / p)^2;
abc_th(2, i, p) = sin(ma.PI * 0.5 * (i+1) / p);
abc_th(3, i, p) = log10(1 + (i+1) / p) / log10(2);
abc_th(4, i, p) = sqrt((i+1) / p);
abc_th(5, i, p) = 1 - cos(ma.PI * 0.5 * (i+1) / p);
abc_th(6, i, p) = (1 - cos(ma.PI * (i+1) / p)) * 0.5;
abc_th(7, i, p) = 1 - (1 - (i+1) / p )^2;
abc_th(8, i, p) = ((i+1) / p < 0.5) * 2 * ((i+1) / p)^2 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^2 * 0.5) ;
abc_th(9, i, p) = ((i+1) / p)^3 ;
abc_th(10, i, p) = 1 - (1 - (i+1) / p)^3 ;
abc_th(11, i, p) = ((i+1) / p < 0.5) * 4 * ((i+1) / p)^3 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^3 * 0.5) ;
abc_th(12, i, p) = ((i+1) / p)^4 ; 
abc_th(13, i, p) = 1 - (1 - (i+1) / p)^4 ;
abc_th(14, i, p) = ((i+1) / p < 0.5) * 8 * ((i+1) / p)^4 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^4 * 0.5) ;
abc_th(15, i, p) = ((i+1) / p)^5 ; 
abc_th(16, i, p) = 1 - (1 - (i+1) / p)^5 ;
abc_th(17, i, p) = ((i+1) / p < 0.5) * 16 * ((i+1) / p)^5 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^5 * 0.5) ;
abc_th(18, i, p) = 2^(10 * (i+1) / p - 10) ;
abc_th(19, i, p) = ((i+1) / p < 1) * (1 - 2^(-10 * (i+1) / p)) + ((i+1) / p == 1) ;
abc_th(20, i, p) = 1 - sqrt(1 - ((i+1) / p)^2) ; 
abc_th(21, i, p) = sqrt(1 - ((i+1) / p - 1)^2) ;
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//PRE-RECORDED BUFFERS FOR TRAJECTORIES AND ABC SOUNDS
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//


